% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HSMclass.R
\name{HSMclass}
\alias{HSMclass}
\title{HSMclass}
\usage{
HSMclass(refdata, predictions, nclasses, moveinterval = 10, iterations,
  coolfactor, InitTemp, weight.norefs, weight.classwidth,
  bestever.iteration = 10, progressbar = TRUE, trace = FALSE)
}
\arguments{
\item{refdata}{\code{\link[base]{vector}} containing the values of the continuous
response variable used in the prediction model}

\item{predictions}{predictions for the response values of the prediction model.
\strong{Note:}(\code{refdata} and \code{predictions} have to correspond to each other)}

\item{nclasses}{number of classes for which an optimal classification scheme should be computed}

\item{moveinterval}{controls if classes should be whole numbers (default is 10).}

\item{iterations}{number of iterations used in heuristic}

\item{coolfactor}{cooling factor of Simulated Annealing algorithm}

\item{InitTemp}{intial Temperature of Simulated Annealing algorithm}

\item{weight.norefs}{weight for maximizing number of reference data pefor each class}

\item{weight.classwidth}{weight for minimizing the classwidth for each class}

\item{bestever.iteration}{number of times the heuristic is repeatedly applied.
If > 1, the best solution over all runs will be chosen
as the optimal solution. Defaults to 10.}

\item{progressbar}{Shows the progress of the heuristic. Defaults to \code{TRUE}.}

\item{trace}{logical. If \code{TRUE}, prints current solution- and penalty-term values to the console.}
}
\value{
\code{HSMclass} returns an object of class \code{"hsmclass"}.


An object of class \code{"hsmclass"} returns a \code{list} of the following components:

 \item{best.classbreaks}{code{vector} containing the class break values of the optimal classification scheme}
 \item{best.classwidth}{{code{vector} containing the class width of each class}}
 \item{no.refs.best}{{code{vector} containing the number of reference data in each class}}
 \item{BestSolution}{value of best solution found by heuristic}
 \item{Solutions}{code{vector} containing all solution values of heuristic}
 \item{bestever.iterationmode}{code{vector} containing the class break values of the optimal classification scheme}
 \item{Temperature}{code{vector} containing the temperature values of the Simulated Annealing algorithm}
 \item{deltaF}{ code{vector} containing the differences between new solution and best solution at the
                respective iteration of the heuristic}
 \item{p}{code{vector} containing the p-values (...). Improvement of Sol.Best always yields p = 1}
 \item{moved.per.iteration}{code{vector} containing the number of classbreaks moved for respective iteration}
 \item{comp.time}{information about the computation time}
 \item{call}{ the function call passed to function \code{HSMclass}}
 \item{settings}{a \code{list} containing the function's inputs:
                   \itemize{
                   \item \code{refdata:}
                   \item \code{predictions:}
                   \item \code{nclasses:}
                   \item \code{iterations:}
                   \item \code{moveinterval:}
                   \item \code{coolfactor:}
                   \item \code{InitTemp:}
                   \item \code{weight.norefs:}
                   \item \code{weight.classwidth:}
                   }}
}
\description{
Identification of optimal classification schemes by Heuritic Search Method (HSM) by Simulated Annealing
}
\examples{
# ------------------------------------------------#
## PERFORM OPTIMIZATION OF CLASSIFICATION SCHEME:

#----
# 1.) Example: optimization for 6 classes:
#----

hsm.1<- HSMclass(refdata = refdata.gr, predictions = predictions.gr,
                 nclasses = 6,iterations = 1000, coolfactor=0.99,
                 InitTemp = 80, weight.norefs = 2, weight.classwidth = 2)
summary(hsm.1)


#----
# 2.) Example: optimization for 6 classes, run heuristic 100 times
#----           and pick best solution over all runs:
 \dontrun{
 hsm.2<- HSMclass(refdata = refdata.gr, predictions = predictions.gr,
                  nclasses = 6,
                  iterations = 1000, coolfactor=0.99, InitTemp = 80,
                  weight.norefs = 2, weight.classwidth = 2,
                  bestever.iteration = 100)
summary(hsm.2)
}


# ------------------------------------------------#
##  PERFORM ENTIRE ANALYSIS:

# define a set of equidistant intervals to evaluate:
equal.intervals<- seq(100,300,20)

# define corresponding number of classes:
n.classes<- ceiling(max(refdata.gr, predictions.gr)/equal.intervals)

# Chain of analysis:
# --> 1. Identify optimal classification scheme for all given number of classes
# --> 2. Calculate classification accuracy for equidistant class intervals
# --> 3. Calculate classification accuracy for corresponding optimal no. of classes

\dontrun{
acc.equal<- list()
acc.opti<-  list()

lapply(seq_along(n.classes), function(x){

  hsm<- HSMclass(refdata.gr, predictions.gr, nclasses = n.classes[x],
                 iterations = 1000, coolfactor = 0.99, InitTemp = 80,
                 weight.norefs = 2, weight.classwidth = 2)

 acc.equal[[x]]<- classAccuracy(refdata.gr, predictions.gr, equal.int = equal.intervals[x])
 acc.opti[[x]]<- classAccuracy(hsm)

})
}

}
\references{
Hill, A., Breschan, J., & Mandallaz, D. (2014). Accuracy assessment of timber
            volume maps using forest inventory data and LiDAR canopy height models.
            \emph{Forests}, \strong{5(9)}, 2253-2275.
}
